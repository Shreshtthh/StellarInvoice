#![no_std]
use soroban_sdk::{contract, contractimpl, contracttype, token, Address, Env, String, Vec};

mod error;
mod storage;

pub use error::Error;
pub use storage::*;

#[derive(Clone, Copy, PartialEq, Eq)]
#[contracttype]
#[repr(u32)]
pub enum InvoiceStatus {
    Draft = 0,
    ListedFixed = 1,
    Sold = 2,
    Settled = 3,
    Defaulted = 4,
    Canceled = 5,
}

#[derive(Clone)]
#[contracttype]
pub struct InvoiceData {
    pub issuer: Address,
    pub owner: Address,
    pub buyer: Option<Address>,
    pub face_amount: i128,
    pub asset: Address,
    pub due_timestamp: u64,
    pub discount_amount: Option<i128>,
    pub status: InvoiceStatus,
    pub created_at: u64,
    pub memo: String,
}

#[contract]
pub struct InvoiceRegistry;

#[contractimpl]
impl InvoiceRegistry {
    pub fn initialize(env: Env, admin: Address, platform_fee_bps: u32) -> Result<(), Error> {
        if env.storage().instance().has(&DataKey::Config) {
            return Err(Error::AlreadyInitialized);
        }

        let config = PlatformConfig {
            admin,
            platform_fee_bps,
        };

        env.storage().instance().set(&DataKey::Config, &config);
        env.storage()
            .instance()
            .set(&DataKey::InvoiceCounter, &0u64);

        Ok(())
    }

    pub fn create_invoice(
        env: Env,
        issuer: Address,
        face_amount: i128,
        asset: Address,
        due_timestamp: u64,
        memo: String,
    ) -> Result<u64, Error> {
        issuer.require_auth();

        if face_amount <= 0 {
            return Err(Error::InvalidAmount);
        }

        let invoice_id: u64 = env
            .storage()
            .instance()
            .get(&DataKey::InvoiceCounter)
            .unwrap_or(0)
            + 1;

        let invoice = InvoiceData {
            issuer: issuer.clone(),
            owner: issuer.clone(),
            buyer: None,
            face_amount,
            asset,
            due_timestamp,
            discount_amount: None,
            status: InvoiceStatus::Draft,
            created_at: env.ledger().timestamp(),
            memo,
        };

        env.storage()
            .persistent()
            .set(&DataKey::Invoice(invoice_id), &invoice);

        env.storage()
            .instance()
            .set(&DataKey::InvoiceCounter, &invoice_id);

        extend_invoice(&env, invoice_id);

        env.events().publish(
            (String::from_str(&env, "invoice_created"), invoice_id),
            issuer,
        );

        Ok(invoice_id)
    }

    pub fn list_fixed(
        env: Env,
        invoice_id: u64,
        discount_amount: i128,
    ) -> Result<(), Error> {
        let mut invoice = Self::get_invoice_internal(&env, invoice_id)?;

        invoice.owner.require_auth();

        if invoice.status != InvoiceStatus::Draft {
            return Err(Error::AlreadyListed);
        }

        if discount_amount <= 0 || discount_amount >= invoice.face_amount {
            return Err(Error::InvalidDiscount);
        }

        invoice.discount_amount = Some(discount_amount);
        invoice.status = InvoiceStatus::ListedFixed;

        env.storage()
            .persistent()
            .set(&DataKey::Invoice(invoice_id), &invoice);

        extend_invoice(&env, invoice_id);

        env.events().publish(
            (String::from_str(&env, "invoice_listed"), invoice_id),
            discount_amount,
        );

        Ok(())
    }

    /// Buy invoice at listed price (DEMO MODE: Token transfer disabled)
    pub fn buy_now(env: Env, buyer: Address, invoice_id: u64) -> Result<(), Error> {
        buyer.require_auth();

        let mut invoice = Self::get_invoice_internal(&env, invoice_id)?;

        if invoice.status != InvoiceStatus::ListedFixed {
            return Err(Error::NotListed);
        }

        let proceeds = invoice.discount_amount.ok_or(Error::InvalidDiscount)?;

        // COMMENTED OUT FOR DEMO - Enable for production with proper token setup
        // let asset_client = token::Client::new(&env, &invoice.asset);
        // asset_client.transfer(&buyer, &invoice.issuer, &proceeds);

        invoice.owner = buyer.clone();
        invoice.buyer = Some(buyer.clone());
        invoice.status = InvoiceStatus::Sold;

        env.storage()
            .persistent()
            .set(&DataKey::Invoice(invoice_id), &invoice);

        extend_invoice(&env, invoice_id);

        env.events().publish(
            (String::from_str(&env, "invoice_sold"), invoice_id),
            (buyer, proceeds),
        );

        Ok(())
    }

    /// Repay invoice
    pub fn repay(env: Env, payer: Address, invoice_id: u64) -> Result<(), Error> {
        payer.require_auth();

        let mut invoice = Self::get_invoice_internal(&env, invoice_id)?;

        if invoice.status != InvoiceStatus::Sold {
            return Err(Error::CannotRepay);
        }

        if env.ledger().timestamp() > invoice.due_timestamp {
            invoice.status = InvoiceStatus::Defaulted;
        } else {
            invoice.status = InvoiceStatus::Settled;

            // COMMENTED OUT FOR DEMO
            // let asset_client = token::Client::new(&env, &invoice.asset);
            // asset_client.transfer(&payer, &invoice.owner, &invoice.face_amount);
        }

        env.storage()
            .persistent()
            .set(&DataKey::Invoice(invoice_id), &invoice);

        extend_invoice(&env, invoice_id);

        env.events().publish(
            (String::from_str(&env, "invoice_repaid"), invoice_id),
            payer,
        );

        Ok(())
    }

    pub fn cancel(env: Env, invoice_id: u64) -> Result<(), Error> {
        let mut invoice = Self::get_invoice_internal(&env, invoice_id)?;

        invoice.issuer.require_auth();

        if invoice.status != InvoiceStatus::Draft && invoice.status != InvoiceStatus::ListedFixed {
            return Err(Error::CannotCancel);
        }

        invoice.status = InvoiceStatus::Canceled;

        env.storage()
            .persistent()
            .set(&DataKey::Invoice(invoice_id), &invoice);

        extend_invoice(&env, invoice_id);

        Ok(())
    }

    pub fn get_invoice(env: Env, invoice_id: u64) -> Result<InvoiceData, Error> {
        Self::get_invoice_internal(&env, invoice_id)
    }

    pub fn get_config(env: Env) -> Result<PlatformConfig, Error> {
        env.storage()
            .instance()
            .get(&DataKey::Config)
            .ok_or(Error::NotInitialized)
    }

    fn get_invoice_internal(env: &Env, invoice_id: u64) -> Result<InvoiceData, Error> {
        env.storage()
            .persistent()
            .get(&DataKey::Invoice(invoice_id))
            .ok_or(Error::InvoiceNotFound)
    }
}
